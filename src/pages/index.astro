---
import { getCollection } from 'astro:content';
import { Markdown } from '@astropub/md'
// Page metadata

// Load utilities markdown modules directly and extract rendered HTML for inline embedding.
// We use import.meta.glob with eager:true so the markdown modules are available at build time.
const modules = import.meta.glob('../content/utilities/*.md', { eager: true });
const utilitiesData = [];

for (const path in modules) {
	const mod = modules[path];
	const fileName = path.split('/').pop();
	const id = fileName.replace(/\.md$/i, '');
	let content = '';

	// Try common ways markdown import exposes compiled HTML:
	// 1) compiledContent() function (some setups)
	if (mod && typeof mod.compiledContent === 'function') {
		try { content = await mod.compiledContent(); } catch (e) { /* ignore */ }
	}

	// 2) compiled string export
	if (!content && typeof mod.compiled === 'string') {
		content = mod.compiled;
	}

	// 3) module-level render() returning { html } (some Astro setups)
	if (!content && mod && typeof mod.render === 'function') {
		try {
			const r = await mod.render();
			if (r && typeof r.html === 'string') content = r.html;
		} catch (e) { /* ignore */ }
	}

	// 4) default component with render() (fallback)
	if (!content && mod && mod.default && typeof mod.default.render === 'function') {
		try {
			const r = await mod.default.render();
			if (r && typeof r.html === 'string') content = r.html;
		} catch (e) { /* ignore */ }
	}

	// 5) fallback to rawContent / raw export if available
	if (!content && typeof mod.rawContent === 'string') {
		content = mod.rawContent;
	}

	// Push normalized entry
	utilitiesData.push({
		id,
		title: (mod && mod.frontmatter && mod.frontmatter.title) || id,
		description: (mod && mod.frontmatter && mod.frontmatter.description) || '',
		category: (mod && mod.frontmatter && mod.frontmatter.category) || '',
		content
	});
}

// Serialize utilities data for client-side (kept for compatibility, but client uses embedded HTML)
const serializedUtilitiesData = JSON.stringify(utilitiesData);

// Generate dynamic fileSystem from utilities and projects
const fileSystem = {
  'github-projects': {
    'bloccChainz': { type: 'project', url: 'https://github.com/rootHytx/bloccChainz' },
    'github': { type: 'project', url: 'https://github.com/rootHytx' },
    'sistemas-embutidos': { type: 'project', url: 'https://github.com/rootHytx/sistemas-embutidos' },
    'trabalho-redes': { type: 'project', url: 'https://github.com/rootHytx/trabalho-redes' }
  },
  'utilities': Object.fromEntries(
    utilitiesData.map(u => [u.id, { type: 'utility', url: u.id }])
  )
};
const serializedFileSystem = JSON.stringify(fileSystem);

// Create JavaScript string literals for safe injection
const utilitiesDataJS = JSON.stringify(serializedUtilitiesData);
const fileSystemJS = JSON.stringify(serializedFileSystem);

// Create script content for raw injection
const dataScriptContent = `
window.utilitiesData = ${serializedUtilitiesData};
window.fileSystem = ${serializedFileSystem};
`;
---



<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>root/hytx</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			@font-face {
				font-family: 'Hack Nerd Font';
				src: url('/fonts/HackNerdFont-Regular.ttf') format('truetype');
				font-weight: 400;
				font-style: normal;
				font-display: swap;
			}
			@font-face {
				font-family: 'Hack Nerd Font';
				src: url('/fonts/HackNerdFont-Bold.ttf') format('truetype');
				font-weight: 700;
				font-style: normal;
				font-display: swap;
			}
			@font-face {
				font-family: 'Hack Nerd Font';
				src: url('/fonts/HackNerdFont-Italic.ttf') format('truetype');
				font-weight: 400;
				font-style: italic;
				font-display: swap;
			}
			@font-face {
				font-family: 'Hack Nerd Font';
				src: url('/fonts/HackNerdFont-BoldItalic.ttf') format('truetype');
				font-weight: 700;
				font-style: italic;
				font-display: swap;
			}
			body {
				background-color: #000000;
				color: #e79cfe;
				/* Use Hack Nerd Font as primary, fall back to common monospace fonts */
				font-family: 'Hack Nerd Font', monospace;
				font-size: 16px;
				line-height: 1.4;
				/* overall page uses full viewport height; layout splits into two areas using vh */
				min-height: 100vh;
				margin: 0;
				display: block;
			}

			.content {
				flex: 1;
				display: flex;
				flex-direction: column;
				align-items: center;
				text-align: center;
				max-width: 800px;
				width: 100%;
				margin: 0 auto;
				padding: 2% 0 0 0;
			}

			.content-area {
				width: 100%;
				/* main content takes 70% of the viewport */
				height: 65vh;
				position: relative;
				overflow: auto;
				box-sizing: border-box;
			}

			.header {
				margin-bottom: 30px;
				display: flex;
				align-items: center;
				gap: 8px;
				justify-content: center;
			}

			.username {
				font-size: 26px;
				font-weight: bold;
				color: #e79cfe;
			}

			.cursor {
				display: inline-block;
				width: 8px;
				height: 16px;
				background-color: #e79cfe;
				animation: blink 1s infinite;
				vertical-align: middle;
			}

			@keyframes blink {
				0%, 50% { opacity: 1; }
				51%, 100% { opacity: 0; }
			}


			.utility-content {
				width: 100%;
				text-align: left;
				display: none;
				/* Fill the available area inside the content-area (70%) */
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background-color: #000000;
				z-index: 10;
				overflow-y: auto;
				padding: 20px;
				/* Custom scrollbar */
				scrollbar-width: thin;
				scrollbar-color: #e79cfe #000000;
				box-sizing: border-box;
			}

			.utility-content::-webkit-scrollbar {
				width: 8px;
			}

			.utility-content::-webkit-scrollbar-track {
				background: #000000;
			}

			.utility-content::-webkit-scrollbar-thumb {
				background: #e79cfe;
				border-radius: 4px;
			}

			.utility-content::-webkit-scrollbar-thumb:hover {
				background: #d18bf5;
			}

			.utility-content.active {
				display: block;
			}

			.utility-content-inner {
				/* main content area inner container */
				max-width: 960px;
				margin: 0 auto;
				padding: 20px;
			}

			.utility-content h1,
			.utility-content h2,
			.utility-content h3 {
				color: #e79cfe;
				margin: 20px 0 10px 0;
				font-family: 'Hack Nerd Font', monospace;
			}

			.utility-content h1 {
				font-size: 24px;
				border-bottom: 1px solid #333;
				padding-bottom: 10px;
			}

			.utility-content h2 {
				font-size: 20px;
			}

			.utility-content h3 {
				font-size: 18px;
			}

			.utility-content p {
				color: #e79cfe;
				line-height: 1.6;
				margin: 10px 0;
				font-family: 'Hack Nerd Font', monospace;
			}

			.utility-content .code-block {
				background-color: #1a1a1a;
				border: 1px solid #333;
				padding: 15px;
				border-radius: 4px;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 14px;
				line-height: 1.4;
				color: #e79cfe;
				overflow-x: auto;
				margin: 15px 0;
				white-space: pre-wrap;
			}

			.utility-content .section {
				margin: 20px 0;
			}

			/* Copy button styles are in a global <style> block below (dynamically created elements) */

			.utility-content .section-title {
				color: #e79cfe;
				font-weight: bold;
				font-size: 18px;
				margin-bottom: 10px;
				font-family: 'Hack Nerd Font', monospace;
			}

			.utility-content .description {
				color: #e79cfe;
				line-height: 1.6;
				margin-bottom: 15px;
				font-family: 'Hack Nerd Font', monospace;
			}

			.utility-content .back-link {
				color: #e79cfe;
				text-decoration: none;
				border-bottom: 1px solid #e79cfe;
				padding-bottom: 2px;
				transition: color 0.2s ease;
				margin-top: auto;
				width: fit-content;
				display: inline-block;
				margin-bottom: 20px;
			}

			.utility-content .back-link:hover {
				color: #ffffff;
				border-bottom-color: #ffffff;
			}

			.back-button {
				color: #e79cfe;
				text-decoration: none;
				border-bottom: 1px solid #e79cfe;
				padding-bottom: 2px;
				transition: color 0.2s ease;
				cursor: pointer;
				margin-bottom: 20px;
				display: inline-block;
			}

			.back-button:hover {
				color: #ffffff;
				border-bottom-color: #ffffff;
			}

			.directory-path {
				color: #e79cfe;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 16px;
				margin-bottom: 8px;
				text-align: left;
			}

			.directory-item {
				display: flex;
				align-items: center;
				gap: 4px;
				padding: 4px 16px;
				cursor: pointer;
				transition: color 0.2s ease;
				justify-content: flex-start;
				width: 100%;
			}

			.directory-item:hover,
			.directory-item.selected {
				color: #ffffff;
			}

			.folder-icon {
				color: #e79cfe;
				font-family: monospace;
			}

			.project-name {
				color: #e79cfe;
			}

			.footer {
				color: #666;
				font-size: 14px;
				text-align: center;
			}

			/* Terminal container (fixed to bottom). All terminal-related children (output and the input area)
			   are scoped under this .terminal wrapper so content does not leak into terminal area. */
			.terminal {
				position: fixed;
				left: 0;
				right: 0;
				bottom: 0;
				height: 25%; /* reserved vertical space for the terminal */
				display: flex;
				flex-direction: column;
				justify-content: space-between;
				background-color: #000000;
				z-index: 1000;
				box-sizing: border-box;
			}

			/* Terminal output sits above the input area inside the terminal container and scrolls independently */
			.terminal .terminal-output {
				position: absolute;
				top: 10%;
				left: 1%;
				right: 1%;
				bottom: 0%;
				/* leave room for the input area at the bottom of the terminal */
				max-height: 75%;
				overflow-y: auto;
				background-color: rgba(0, 0, 0, 0.8);
				border: 1px solid #333;
				padding: 10px;
				display: block;
				box-sizing: border-box;
				/* Custom scrollbar to match utilities area */
				scrollbar-width: thin;
				scrollbar-color: #e79cfe #000000;
			}
			.terminal .terminal-output::-webkit-scrollbar {
				width: 8px;
			}
			.terminal .terminal-output::-webkit-scrollbar-track {
				background: #000000;
			}
			.terminal .terminal-output::-webkit-scrollbar-thumb {
				background: #e79cfe;
				border-radius: 4px;
			}
			.terminal .terminal-output::-webkit-scrollbar-thumb:hover {
				background: #d18bf5;
			}

			/* Input area (real-terminal) anchored to the bottom of the .terminal container */
			.terminal .real-terminal {
				position: absolute;
				left: 0;
				right: 0;
				bottom: 0;
				height: 15%; /* fixed input area height within the terminal */
				background-color: #000000;
				border-top: 1px solid #333;
				padding: 12px 20px;
				display: flex;
				align-items: center;
				gap: 8px;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 16px;
				box-sizing: border-box;
			}

			.terminal-prompt {
				color: #e79cfe;
				font-weight: bold;
				white-space: nowrap;
			}

			.terminal-input {
				background: transparent;
				border: none;
				color: #bbb;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 16px;
				outline: none;
				flex: 1;
				caret-color: #e79cfe;
			}

			.terminal-input::placeholder {
				color: #666;
			}

			/* .terminal-output active rule removed — terminal output is visible by default inside .terminal */

			.terminal-line {
				color: #e79cfe;
				line-height: 1.4;
				margin-bottom: 4px;
				white-space: pre-wrap;
			}

			.terminal-command {
				color: #00ff00;
			}


		</style>
		<style is:global>
			.code-block-wrapper {
				position: relative;
			}

			.code-block-wrapper pre {
				margin: 0;
				padding: 16px 20px !important;
			}

			.copy-btn {
				position: absolute;
				top: 6px;
				right: 6px;
				background: none;
				border: none;
				font-size: 16px;
				padding: 2px;
				cursor: pointer;
				opacity: 0;
				transition: opacity 0.2s ease, transform 0.15s ease;
				z-index: 5;
				line-height: 1;
			}

			.code-block-wrapper:hover .copy-btn {
				opacity: 0.7;
			}

			.copy-btn:hover {
				opacity: 1 !important;
				transform: scale(1.15);
			}

			.code-block-wrapper.focused pre {
				outline: 2px solid #e79cfe;
				outline-offset: -2px;
				border-radius: 4px;
			}

			/* Keybind cheat sheet modal */
			.keybind-modal {
				display: none;
				position: fixed;
				inset: 0;
				z-index: 9999;
				background: rgba(0, 0, 0, 0.85);
				align-items: center;
				justify-content: center;
			}

			.keybind-modal.active {
				display: flex;
			}

			.keybind-modal-content {
				background: #111;
				border: 1px solid #e79cfe;
				border-radius: 6px;
				padding: 36px 48px !important;
				max-width: 900px;
				width: 92%;
				max-height: 80vh;
				overflow-y: auto;
				scrollbar-width: thin;
				scrollbar-color: #e79cfe #111;
				font-family: 'Hack Nerd Font', monospace;
				color: #e79cfe;
			}

			.keybind-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				border-bottom: 1px solid #333;
				padding-bottom: 12px !important;
				margin-bottom: 20px !important;
				font-size: 18px;
				font-weight: bold;
			}

			.keybind-close {
				font-size: 12px;
				font-weight: normal;
				color: #666;
			}

			.keybind-columns {
				display: flex;
				flex-wrap: wrap;
				gap: 24px;
			}

			.keybind-section {
				flex: 1 1 280px;
				min-width: 250px;
				margin-bottom: 8px !important;
			}

			.keybind-section-title {
				font-size: 14px;
				font-weight: bold;
				color: #fff;
				margin-bottom: 10px !important;
				border-bottom: 1px solid #333;
				padding-bottom: 6px !important;
			}

			.keybind-row {
				display: flex;
				align-items: center;
				padding: 4px 0 !important;
				font-size: 13px;
			}

			.keybind-row kbd {
				background: #222;
				border: 1px solid #444;
				border-radius: 3px;
				padding: 2px 7px !important;
				margin-right: 4px !important;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 12px;
				color: #e79cfe;
				white-space: nowrap;
			}

			.keybind-row span {
				color: #999;
				margin-left: auto;
				padding-left: 16px !important;
				white-space: nowrap;
			}
		</style>
	</head>
	<body>

		<div class="content">
			<div class="header">
				<span class="username">root/hytx</span>
				<span class="cursor"></span>
			</div>

			<div class="content-area">
				<div id="directory-view">
					<div class="directory-path">/root/github-projects</div>
					<div class="directory-listing">
						<div class="directory-item" data-type="project" data-url="https://github.com/rootHytx/sistemas-embutidos" data-content-length="0">
							<span class="folder-icon">└─</span>
							<span class="project-path">/root/github-projects/sistemas-embutidos</span>
						</div>
						<div class="directory-item" data-type="project" data-url="https://github.com/rootHytx/bloccChainz" data-content-length="0">
							<span class="folder-icon">└─</span>
							<span class="project-path">/root/github-projects/bloccChainz</span>
						</div>
						<div class="directory-item" data-type="project" data-url="https://github.com/rootHytx/trabalho-redes" data-content-length="0">
							<span class="folder-icon">└─</span>
							<span class="project-path">/root/github-projects/trabalho-redes</span>
						</div>
						<div class="directory-item" data-type="project" data-url="https://github.com/rootHytx" data-content-length="0">
							<span class="folder-icon">└─</span>
							<span class="project-path">/root/github-projects/github</span>
						</div>
					</div>

					<div class="directory-path" style="margin-top: 30px;">/root/utilities</div>
					{utilitiesData.map((u) => (
						<div class="directory-item" data-type="utility" data-url={u.id.replace(/\.md$/i, '')} data-content-length={u.content ? u.content.length : 0}>
							<span class="folder-icon">└─</span>
							<span class="project-path">{`/root/utilities/${u.id.replace(/\.md$/i, '')}`}</span>
							<!-- Hidden inline copy of the rendered markdown HTML (server-rendered). Inject raw HTML with set:html -->
							<div class="item-content" style="display:none;" set:html={u.content}></div>
						</div>
					))}
				</div>

				<div id="utility-view" class="utility-content">
					<div class="utility-content-inner">
						<div class="back-button" id="back-button">← Back to directory</div>
						<div id="utility-content"></div>
					</div>
				</div>
			</div>
		</div>

		<div class="terminal">
			<div class="footer">
				<span>Press ESC to toggle input focus | Press ? for keybinds</span>
			</div>

			<div class="terminal-output" id="terminal-output"></div>

			<div class="real-terminal">
				<div class="terminal-prompt">[rootHytx@github.io: <span id="prompt-dir">~</span>]$</div>
				<input type="text" class="terminal-input" id="terminal-input" placeholder="Type commands here...">
			</div>
		</div>

		<div id="keybind-modal" class="keybind-modal">
			<div class="keybind-modal-content">
				<div class="keybind-header">
					<span>Keybinds Cheat Sheet</span>
					<span class="keybind-close">Press ? or ESC to close</span>
				</div>
				<div class="keybind-columns">
					<div class="keybind-section">
						<div class="keybind-section-title">Global</div>
						<div class="keybind-row"><kbd>ESC</kbd><span>Toggle terminal input focus</span></div>
						<div class="keybind-row"><kbd>?</kbd><span>Toggle this cheat sheet</span></div>
					</div>
					<div class="keybind-section">
						<div class="keybind-section-title">Directory Navigation</div>
						<div class="keybind-row"><kbd>j</kbd> <kbd>&#x2193;</kbd><span>Move selection down</span></div>
						<div class="keybind-row"><kbd>k</kbd> <kbd>&#x2191;</kbd><span>Move selection up</span></div>
						<div class="keybind-row"><kbd>l</kbd> <kbd>Enter</kbd><span>Open selected item</span></div>
						<div class="keybind-row"><kbd>Backspace</kbd><span>Go back from utility</span></div>
					</div>
					<div class="keybind-section">
						<div class="keybind-section-title">Utility View - Scroll</div>
						<div class="keybind-row"><kbd>j</kbd> <kbd>&#x2193;</kbd><span>Scroll down</span></div>
						<div class="keybind-row"><kbd>k</kbd> <kbd>&#x2191;</kbd><span>Scroll up</span></div>
						<div class="keybind-row"><kbd>Ctrl+d</kbd><span>Half-page down</span></div>
						<div class="keybind-row"><kbd>Ctrl+u</kbd><span>Half-page up</span></div>
						<div class="keybind-row"><kbd>g</kbd> <kbd>Home</kbd><span>Scroll to top</span></div>
						<div class="keybind-row"><kbd>G</kbd> <kbd>End</kbd><span>Scroll to bottom</span></div>
						<div class="keybind-row"><kbd>PgDn</kbd> <kbd>PgUp</kbd><span>Page scroll</span></div>
					</div>
					<div class="keybind-section">
						<div class="keybind-section-title">Utility View - Code Blocks</div>
						<div class="keybind-row"><kbd>h</kbd> <kbd>&#x2190;</kbd><span>Scroll focused block left</span></div>
						<div class="keybind-row"><kbd>l</kbd> <kbd>&#x2192;</kbd><span>Scroll focused block right</span></div>
						<div class="keybind-row"><kbd>y</kbd><span>Yank (copy) focused block</span></div>
					</div>
					<div class="keybind-section">
						<div class="keybind-section-title">Terminal</div>
						<div class="keybind-row"><kbd>Tab</kbd><span>Autocomplete commands/files</span></div>
						<div class="keybind-row"><kbd>Enter</kbd><span>Execute command</span></div>
					</div>
				</div>
			</div>
		</div>

		<script>
			// Simple command system
			document.addEventListener('DOMContentLoaded', function() {
				let isInputFocused = true; // Start with input focused
				const terminalOutput = document.getElementById('terminal-output') as HTMLElement | null;
				const terminalInput = document.getElementById('terminal-input') as HTMLInputElement | null;
				const directoryListing = document.querySelector('.directory-listing');
				const directoryPath = document.querySelector('.directory-path');
				const footer = document.querySelector('.footer');

				// Directory structure - loaded from server-side generated data
				let fileSystem = window.fileSystem || {
					'github-projects': {
						'bloccChainz': { type: 'project', url: 'https://github.com/rootHytx/bloccChainz' },
						'github': { type: 'project', url: 'https://github.com/rootHytx' },
						'sistemas-embutidos': { type: 'project', url: 'https://github.com/rootHytx/sistemas-embutidos' },
						'trabalho-redes': { type: 'project', url: 'https://github.com/rootHytx/trabalho-redes' }
					},
					'utilities': {}
				};

				// If fileSystem is a string (JSON), parse it
				if (typeof fileSystem === 'string') {
					try {
						fileSystem = JSON.parse(fileSystem);
					} catch (e) {
						console.error('Failed to parse fileSystem:', e);
					}
				}

				// If utilities is still empty, try to build from utilitiesData
				if (fileSystem.utilities && Object.keys(fileSystem.utilities).length === 0 && window.utilitiesData) {
					try {
						let utilitiesData = window.utilitiesData;
						if (typeof utilitiesData === 'string') {
							utilitiesData = JSON.parse(utilitiesData);
						}
						if (Array.isArray(utilitiesData)) {
							utilitiesData.forEach(u => {
								if (u && u.id) {
									fileSystem.utilities[u.id] = { type: 'utility', url: u.id };
								}
							});
						}
					} catch (e) {
						console.error('Failed to build utilities from utilitiesData:', e);
					}
				}

				// Utility content cache
				const utilityContent = {};
				let currentUtility = null;

				let currentDirectory = '~';

				// Command definitions
				const commands = {
					help: function(): string {
						return `
Available commands:
- help: Show this help message
- ls: List files in current directory
- cd [directory]: Navigate to directory
- cat [file]: Read file contents
- clear: Clear the terminal
- pwd: Show current directory
						`;
					},
					ls: function(): string {
							if (currentDirectory === '~') {
								return Object.keys(fileSystem).map(dir => dir + '/').join('\n');
							} else if (fileSystem[currentDirectory]) {
								return Object.keys(fileSystem[currentDirectory]).join('\n');
							}
							return '';
						},
					cd: function(dir: string): string {
						if (!dir) {
							currentDirectory = '~';
							updatePrompt();
							return '';
						}

						if (dir === '..' || dir === '../') {
							currentDirectory = '~';
							updatePrompt();
							return '';
						}

						// Remove trailing slash if present
						const dirName = dir.replace(/\/$/, '');
						if (fileSystem[dirName]) {
							currentDirectory = dirName;
							updatePrompt();
							return '';
						}

						return `cd: ${dir}: No such directory`;
					},
					cat: function(file: string): string {
						if (!file) {
							return 'Usage: cat [filename]';
						}

						if (currentDirectory === 'github-projects') {
							const project = fileSystem['github-projects'][file as keyof typeof fileSystem['github-projects']];
							if (project) {
								// Open the project URL
								window.open(project.url, '_blank');
								return `Opening ${file}...`;
							}
						} else if (currentDirectory === 'utilities') {
							const utility = fileSystem['utilities'][file as keyof typeof fileSystem['utilities']];
							if (utility) {
								// Load utility content in-place
								loadUtility(file);
								return `Loading ${file}...`;
							}
						}

						return `cat: ${file}: No such file`;
					},
					pwd: function(): string {
						return currentDirectory === '~' ? '/root' : `/root/${currentDirectory}`;
					},
					clear: function(): string {
						if (!terminalOutput) return '';
						terminalOutput.innerHTML = '';
						return '';
					}
				};

				// Execute command
				function executeCommand(input: string) {
					if (!terminalOutput) return;

					const parts = input.trim().split(' ');
					const command = parts[0].toLowerCase();
					const args = parts.slice(1);

					if (commands[command as keyof typeof commands]) {
						const result = commands[command as keyof typeof commands](...args);
						if (result) {
							terminalOutput.innerHTML += '<div class="terminal-line">' + result.replace(/\n/g, '<br>') + '</div>';
						}
					} else if (input.trim()) {
						terminalOutput.innerHTML += '<div class="terminal-line">Command not found: ' + command + '. Type "help" for available commands.</div>';
					}

					terminalOutput.scrollTop = terminalOutput.scrollHeight;
				}

				// Tab completion handler
				function handleTabCompletion(inputText: string) {
					if (!terminalInput || !terminalOutput) return inputText;

					const parts = inputText.trim().split(/\s+/);
					const cursorPos = terminalInput.selectionStart ?? inputText.length;
					const textBeforeCursor = inputText.substring(0, cursorPos);
					const currentPartIndex = textBeforeCursor.trim().split(/\s+/).length - 1;
					const isCommand = currentPartIndex === 0;

					if (isCommand) {
						// Complete command name
						const partial = parts[0] || '';
						const matches = Object.keys(commands).filter(cmd =>
							cmd.startsWith(partial.toLowerCase())
						);

						if (matches.length === 1) {
							return matches[0] + ' ';
						} else if (matches.length > 1) {
							// Find common prefix
							let commonPrefix = matches[0];
							for (let i = 1; i < matches.length; i++) {
								while (!matches[i].startsWith(commonPrefix)) {
									commonPrefix = commonPrefix.slice(0, -1);
								}
							}
							if (commonPrefix.length > partial.length) {
								return commonPrefix;
							} else {
								// Show available matches
								terminalOutput.innerHTML += '<div class="terminal-line">' + matches.join('  ') + '</div>';
								terminalOutput.scrollTop = terminalOutput.scrollHeight;
								return inputText;
							}
						}
					} else {
						// Complete argument (file/directory)
						const command = parts[0]?.toLowerCase() || '';
						const partial = parts[currentPartIndex] || '';

						let matches: string[] = [];
						if (command === 'cd') {
							// Directory completion
							if (currentDirectory === '~') {
								matches = Object.keys(fileSystem).map(dir => dir + '/').filter(dir =>
									dir.startsWith(partial)
								);
							} else if (fileSystem[currentDirectory]) {
								matches = Object.keys(fileSystem[currentDirectory]).filter(item =>
									item.startsWith(partial)
								);
								// Add ../ for navigation
								if ('../'.startsWith(partial)) {
									matches.push('../');
								}
							}
						} else if (command === 'cat' || command === 'ls') {
							// File completion (same as directory completion for this system)
							if (currentDirectory === '~') {
								matches = Object.keys(fileSystem).map(dir => dir + '/').filter(file =>
									file.startsWith(partial)
								);
							} else if (fileSystem[currentDirectory]) {
								matches = Object.keys(fileSystem[currentDirectory]).filter(file =>
									file.startsWith(partial)
								);
							}
						}

						// Process matches
						if (matches.length === 1) {
							const lastPartialIndex = textBeforeCursor.lastIndexOf(partial);
							const completion = matches[0] + (matches[0].endsWith('/') ? '' : ' ');
							return inputText.substring(0, lastPartialIndex) + completion + inputText.substring(cursorPos);
						} else if (matches.length > 1) {
							// Find common prefix
							let commonPrefix = matches[0];
							for (let i = 1; i < matches.length; i++) {
								while (!matches[i].startsWith(commonPrefix)) {
									commonPrefix = commonPrefix.slice(0, -1);
								}
							}
							if (commonPrefix.length > partial.length) {
								const lastPartialIndex = textBeforeCursor.lastIndexOf(partial);
								return inputText.substring(0, lastPartialIndex) + commonPrefix + inputText.substring(cursorPos);
							} else {
								// Show available matches
								terminalOutput.innerHTML += '<div class="terminal-line">' + matches.join('  ') + '</div>';
								terminalOutput.scrollTop = terminalOutput.scrollHeight;
								return inputText;
							}
						}
					}

					return inputText; // No matches
				}

				// Toggle input focus
				function toggleInputFocus() {
					isInputFocused = !isInputFocused;

					if (isInputFocused) {
						terminalInput!.focus();
						terminalInput!.placeholder = "Type commands here...";
					} else {
						terminalInput!.blur();
						terminalInput!.placeholder = "Press ESC to focus input...";
					}
				}

				// Update the visible prompt directory shown to the user
				function updatePrompt() {
					const promptDirEl = document.getElementById('prompt-dir');
					if (promptDirEl) {
						promptDirEl.textContent = currentDirectory === '~' ? '~' : currentDirectory;
					}
				}

				// Load utility content (robust to different shapes/formats of injected utilities data)
				async function loadUtility(utilityName) {
					// Normalize the incoming name: strip a trailing .md if present so lookups match ids like "utility-belt"
					let normalizedName = (utilityName || '').toString();
					if (normalizedName.toLowerCase().endsWith('.md')) {
						normalizedName = normalizedName.replace(/\.md$/i, '');
					}

					currentUtility = normalizedName;
					const directoryView = document.getElementById('directory-view');
					const utilityView = document.getElementById('utility-view');
					const utilityContentDiv = document.getElementById('utility-content');

					// Switch views
					directoryView.style.display = 'none';
					utilityView.classList.add('active');

					try {
						// Normalize possible shapes for window.utilitiesData:
						// - already an array of utilities
						// - a JSON string
						// - an object with property 'serializedUtilitiesData' that is a JSON string
						// - an object with property 'utilities' which is an array
						// - an object mapping ids -> utility objects
						let utils = window.utilitiesData;

						// If a JSON string was injected (double-encoded), try to parse
						if (typeof utils === 'string') {
							try { utils = JSON.parse(utils); } catch (e) { /* ignore parse error */ }
						}

						// If the server injected an object wrapper { serializedUtilitiesData: [...] }
						if (utils && typeof utils === 'object' && typeof utils.serializedUtilitiesData === 'string') {
							try { utils = JSON.parse(utils.serializedUtilitiesData); } catch (e) { /* ignore */ }
						}

						// If it's an object with .utilities array, use that
						if (utils && typeof utils === 'object' && Array.isArray(utils.utilities)) {
							utils = utils.utilities;
						}

						// Resolve utility entry whether utils is array or map. Accept either the normalized name
						// or the original incoming name for maximum compatibility.
						let utilityData = null;
						if (Array.isArray(utils)) {
							utilityData = utils.find(u => {
								// common possible id/name fields
								if (!u) return false;
								const uId = (u.id || u.slug || (u.data && u.data.id) || '').toString();
								return uId === normalizedName || uId === utilityName;
							});
						} else if (utils && typeof utils === 'object') {
							// object keyed by id (or slug)
							if (utils[normalizedName]) {
								utilityData = utils[normalizedName];
							} else if (utils[utilityName]) {
								utilityData = utils[utilityName];
							} else {
								// fallback: first object value that matches id/slug
								utilityData = Object.values(utils).find(u => {
									if (!u) return false;
									const uId = (u.id || u.slug || (u.data && u.data.id) || '').toString();
									return uId === normalizedName || uId === utilityName;
								});
							}
						}

						// Attempt to normalize content HTML from different shapes
						let contentHtml = null;
						if (utilityData) {
							// direct html/content fields
							if (typeof utilityData.content === 'string') {
								contentHtml = utilityData.content;
							} else if (typeof utilityData.html === 'string') {
								contentHtml = utilityData.html;
							} else if (typeof utilityData.body === 'string') {
								contentHtml = utilityData.body;
							} else if (utilityData.render && typeof utilityData.render === 'function') {
								// some Astro content objects provide a render() returning { html, css, ... }
								try {
									const rendered = utilityData.render();
									if (rendered && typeof rendered.html === 'string') {
										contentHtml = rendered.html;
									}
								} catch (e) {
									// ignore render errors
								}
							} else if (utilityData.data && typeof utilityData.data.content === 'string') {
								contentHtml = utilityData.data.content;
							} else if (utilityData.data && utilityData.data.render && typeof utilityData.data.render === 'function') {
								try {
									const rendered = utilityData.data.render();
									if (rendered && typeof rendered.html === 'string') {
										contentHtml = rendered.html;
									}
								} catch (e) { /* ignore */ }
							}
						}

						if (contentHtml) {
							// Use the pre-rendered markdown content if available
							utilityContentDiv.innerHTML = '<div class="utility-content">' + contentHtml + '</div>';
							injectCopyButtons(utilityContentDiv);
							updateFocusedCodeBlock();
						} else {
							// Fallback: try to find the inline hidden `.item-content` inside the directory listing and use that HTML.
							try {
								// Try a few selectors: prefer the normalized id, then the raw name, then search by project-path text.
								const byDataUrlNormalized = document.querySelector('.directory-item[data-url=\"' + normalizedName + '\"]');
								const byDataUrlRaw = document.querySelector('.directory-item[data-url=\"' + utilityName + '\"]');
								let directoryItem = byDataUrlNormalized || byDataUrlRaw;

								if (!directoryItem) {
									// Try to match by project-path text content containing the normalized name
									const allItems = Array.from(document.querySelectorAll('.directory-item'));
									directoryItem = allItems.find(i => {
										const pathEl = i.querySelector('.project-path');
										return pathEl && pathEl.textContent && pathEl.textContent.includes(normalizedName);
									});
								}

								if (directoryItem) {
									const inline = directoryItem.querySelector('.item-content');
									if (inline && inline.innerHTML && inline.innerHTML.trim()) {
										utilityContentDiv.innerHTML = '<div class=\"utility-content\">' + inline.innerHTML + '</div>';
										injectCopyButtons(utilityContentDiv);
										updateFocusedCodeBlock();
									} else {
										utilityContentDiv.innerHTML = '<div class=\"terminal-line\">Error: Could not load utility content for ' + normalizedName + '</div>';
									}
								} else {
									utilityContentDiv.innerHTML = '<div class=\"terminal-line\">Error: Could not load utility content for ' + normalizedName + '</div>';
								}
							} catch (e) {
								utilityContentDiv.innerHTML = '<div class=\"terminal-line\">Error: Could not load utility content for ' + normalizedName + '</div>';
							}
						}
					} catch (error) {
						utilityContentDiv.innerHTML = '<div class=\"terminal-line\">Error loading utility: ' + normalizedName + '</div>';
					}
				}

				// Wrap each <pre> in a div and add a copy button overlay
				function injectCopyButtons(container) {
					if (!container) return;
					const preBlocks = Array.from(container.querySelectorAll('pre'));
					preBlocks.forEach(function(pre) {
						// Skip if already wrapped
						if (pre.parentElement && pre.parentElement.classList.contains('code-block-wrapper')) return;

						var wrapper = document.createElement('div');
						wrapper.className = 'code-block-wrapper';
						pre.parentNode.insertBefore(wrapper, pre);
						wrapper.appendChild(pre);

						var btn = document.createElement('button');
						btn.className = 'copy-btn';
						btn.textContent = '\u{1F4CB}';
						btn.addEventListener('click', function(e) {
							e.stopPropagation();
							var code = pre.querySelector('code');
							var text = code ? code.textContent : pre.textContent;
							navigator.clipboard.writeText(text).then(function() {
								btn.textContent = '\u2705';
								setTimeout(function() {
									btn.textContent = '\u{1F4CB}';
								}, 2000);
							});
						});
						wrapper.appendChild(btn);
					});
				}

				// Get utility content directly
				function getUtilityContent(utilityName) {
					// Utility content will be loaded dynamically
					return '<div class="terminal-line">Loading ' + utilityName + '...</div>';
				}

				// Go back to directory view
				function goBackToDirectory() {
					const directoryView = document.getElementById('directory-view');
					const utilityView = document.getElementById('utility-view');

					directoryView.style.display = 'block';
					utilityView.classList.remove('active');
					currentUtility = null;
				}

				// Command input handler
				terminalInput.addEventListener('keydown', function(e) {
					if (e.key === 'Enter') {
						e.preventDefault(); // Prevent any default behavior
						const command = terminalInput!.value;
						if (command.trim()) {
							// Update prompt with current directory
							const promptDir = currentDirectory === '~' ? '~' : currentDirectory;
							terminalOutput!.innerHTML += '<div class="terminal-line"><span class="terminal-command">[rootHytx@github.io: ' + promptDir + ']$ ' + command + '</span></div>';
							executeCommand(command);
							terminalInput!.value = '';
						}
					} else if (e.key === 'Tab') {
						e.preventDefault(); // Prevent tab from moving focus
						const newText = handleTabCompletion(terminalInput!.value);
						if (newText !== terminalInput!.value) {
							terminalInput!.value = newText;
							// Place cursor at end of completion
							terminalInput!.selectionStart = terminalInput!.selectionEnd = newText.length;
						}
					}
				});

				// Keybind cheat sheet modal
				const keybindModal = document.getElementById('keybind-modal');

				function toggleKeybindModal() {
					if (keybindModal) keybindModal.classList.toggle('active');
				}

				function isKeybindModalOpen() {
					return keybindModal && keybindModal.classList.contains('active');
				}

				// ? key handler — works everywhere except when typing in terminal
				document.addEventListener('keydown', function(e) {
					if (e.key === '?' && !(isInputFocused && document.activeElement === terminalInput)) {
						e.preventDefault();
						toggleKeybindModal();
					}
				});

				// Click outside modal content to close
				if (keybindModal) {
					keybindModal.addEventListener('click', function(e) {
						if (e.target === keybindModal) {
							keybindModal.classList.remove('active');
						}
					});
				}

				// ESC key handler
				document.addEventListener('keydown', function(e) {
					if (e.key === 'Escape') {
						if (isKeybindModalOpen()) {
							keybindModal.classList.remove('active');
							return;
						}
						if (currentUtility && !isInputFocused) {
							goBackToDirectory();
						} else {
							toggleInputFocus();
						}
					}
				});

				// Initialize with input focused
				terminalInput.focus();
				terminalOutput.classList.add('active');

				// Show help on first load
				if (terminalOutput.innerHTML === '') {
					terminalOutput.innerHTML = '<div class="terminal-line">' + commands.help().replace(/\n/g, '<br>') + '</div>';
					terminalOutput.scrollTop = terminalOutput.scrollHeight;
				}

				                // Directory item click handlers
				                function setupDirectoryItems() {
				                    const items = document.querySelectorAll('.directory-item');
				                    items.forEach(function(item) {
				                        item.addEventListener('click', function() {
				                            const type = this.getAttribute('data-type');
				                            const url = this.getAttribute('data-url');

				                            if (type === 'project') {
				                                window.open(url, '_blank');
				                                return;
				                            }

				                            if (type === 'utility') {
				                                // Prefer inline pre-rendered HTML embedded in the DOM
				                                const inline = this.querySelector('.item-content');
				                                const directoryView = document.getElementById('directory-view');
				                                const utilityView = document.getElementById('utility-view');
				                                const utilityContentDiv = document.getElementById('utility-content');

				                                if (inline && inline.innerHTML && inline.innerHTML.trim()) {
				                                    // Show utility view using the inline HTML
				                                    directoryView.style.display = 'none';
				                                    utilityView.classList.add('active');
				                                    utilityContentDiv.innerHTML = '<div class="utility-content">' + inline.innerHTML + '</div>';
				                                    injectCopyButtons(utilityContentDiv);
				                                    updateFocusedCodeBlock();
				                                    currentUtility = url;
				                                } else {
				                                    // Fallback to existing loader when inline content isn't available
				                                    loadUtility(url);
				                                }
				                            }
				                        });
				                    });
				                }

				// Back button handler
				document.getElementById('back-button').addEventListener('click', goBackToDirectory);

				// Find and highlight the topmost visible code block in the utility view
				function updateFocusedCodeBlock() {
					const utilityView = document.getElementById('utility-view');
					if (!utilityView || !utilityView.classList.contains('active')) return;

					var wrappers = utilityView.querySelectorAll('.code-block-wrapper');
					if (!wrappers.length) return;

					var viewRect = utilityView.getBoundingClientRect();
					// Threshold line at 30% from top — blocks that scroll past this are considered "gone"
					var threshold = viewRect.top + utilityView.clientHeight * 0.3;
					var atBottom = utilityView.scrollTop + utilityView.clientHeight >= utilityView.scrollHeight - 5;

					var found = null;

					if (atBottom) {
						// At bottom: pick the last visible code block
						for (var i = wrappers.length - 1; i >= 0; i--) {
							var rect = wrappers[i].getBoundingClientRect();
							if (rect.bottom > viewRect.top && rect.top < viewRect.bottom) {
								found = wrappers[i];
								break;
							}
						}
					} else {
						// Normal: pick the first block whose bottom is still below the threshold
						for (var i = 0; i < wrappers.length; i++) {
							var rect = wrappers[i].getBoundingClientRect();
							// Block must be at least partially visible
							if (rect.bottom > viewRect.top && rect.top < viewRect.bottom) {
								// Pick this block if its bottom hasn't scrolled past the threshold
								if (rect.bottom > threshold) {
									found = wrappers[i];
									break;
								}
							}
						}
						// Fallback: if all blocks are above threshold, pick the last visible one
						if (!found) {
							for (var i = wrappers.length - 1; i >= 0; i--) {
								var rect = wrappers[i].getBoundingClientRect();
								if (rect.bottom > viewRect.top && rect.top < viewRect.bottom) {
									found = wrappers[i];
									break;
								}
							}
						}
					}

					wrappers.forEach(function(w) { w.classList.remove('focused'); });
					if (found) found.classList.add('focused');
				}

				// Listen for scroll on the utility view to update focused block
				(function() {
					var utilityView = document.getElementById('utility-view');
					if (utilityView) {
						utilityView.addEventListener('scroll', updateFocusedCodeBlock);
					}
				})();

				// Keyboard navigation for directory mode and utility scrolling
				document.addEventListener('keydown', function(e) {
					if (isInputFocused) return;
					if (isKeybindModalOpen()) return;

					// Check if we're viewing a utility content (utility view is active)
					const utilityView = document.getElementById('utility-view');
					if (utilityView && utilityView.classList.contains('active')) {
						var focused = utilityView.querySelector('.code-block-wrapper.focused pre');
						var scrollAmount = 40;

						// Horizontal scroll of focused code block: ArrowLeft/ArrowRight/h/l
						if (focused && (e.key === 'ArrowLeft' || e.key === 'h')) {
							e.preventDefault();
							focused.scrollLeft -= scrollAmount;
							return;
						} else if (focused && (e.key === 'ArrowRight' || e.key === 'l')) {
							e.preventDefault();
							focused.scrollLeft += scrollAmount;
							return;
						}

						// Yank (copy) focused code block: y
						if (focused && e.key === 'y') {
							e.preventDefault();
							var code = focused.querySelector('code');
							var text = code ? code.textContent : focused.textContent;
							var btn = focused.parentElement.querySelector('.copy-btn');
							navigator.clipboard.writeText(text).then(function() {
								if (btn) {
									btn.textContent = '\u2705';
									btn.style.opacity = '1';
									setTimeout(function() {
										btn.textContent = '\u{1F4CB}';
										btn.style.opacity = '';
									}, 2000);
								}
							});
							return;
						}

						// Vertical scroll: ArrowDown/j
						if (e.key === 'ArrowDown' || e.key === 'j') {
							e.preventDefault();
							utilityView.scrollTop += scrollAmount;
							updateFocusedCodeBlock();
							return;
						// Vertical scroll: ArrowUp/k
						} else if (e.key === 'ArrowUp' || e.key === 'k') {
							e.preventDefault();
							utilityView.scrollTop -= scrollAmount;
							updateFocusedCodeBlock();
							return;
						// Half-page down: Ctrl+d
						} else if (e.key === 'd' && e.ctrlKey) {
							e.preventDefault();
							utilityView.scrollTop += utilityView.clientHeight * 0.5;
							updateFocusedCodeBlock();
							return;
						// Half-page up: Ctrl+u
						} else if (e.key === 'u' && e.ctrlKey) {
							e.preventDefault();
							utilityView.scrollTop -= utilityView.clientHeight * 0.5;
							updateFocusedCodeBlock();
							return;
						} else if (e.key === 'PageDown') {
							e.preventDefault();
							utilityView.scrollTop += utilityView.clientHeight * 0.9;
							updateFocusedCodeBlock();
							return;
						} else if (e.key === 'PageUp') {
							e.preventDefault();
							utilityView.scrollTop -= utilityView.clientHeight * 0.9;
							updateFocusedCodeBlock();
							return;
						// Top of page: Home/gg (g is handled as single key for simplicity -> Home)
						} else if (e.key === 'Home') {
							e.preventDefault();
							utilityView.scrollTop = 0;
							updateFocusedCodeBlock();
							return;
						// Bottom of page: End/G
						} else if (e.key === 'End' || (e.key === 'G' && !e.ctrlKey)) {
							e.preventDefault();
							utilityView.scrollTop = utilityView.scrollHeight;
							updateFocusedCodeBlock();
							return;
						// Top of page: g (double-tap gg handled simply as single g for usability)
						} else if (e.key === 'g' && !e.ctrlKey) {
							e.preventDefault();
							utilityView.scrollTop = 0;
							updateFocusedCodeBlock();
							return;
						}
					}

					// If not scrolling utility content, handle directory navigation
					const items = document.querySelectorAll('.directory-item');
					let currentIndex = -1;

					// Find current focused item
					items.forEach(function(item, index) {
						if (item.classList.contains('selected')) {
							currentIndex = index;
						}
					});

					if (e.key === 'ArrowDown' || e.key === 'j') {
						e.preventDefault();
						const nextIndex = (currentIndex + 1) % items.length;
						items.forEach(function(item) { item.classList.remove('selected'); });
						items[nextIndex].classList.add('selected');
					} else if (e.key === 'ArrowUp' || e.key === 'k') {
						e.preventDefault();
						const prevIndex = currentIndex <= 0 ? items.length - 1 : currentIndex - 1;
						items.forEach(function(item) { item.classList.remove('selected'); });
						items[prevIndex].classList.add('selected');
					} else if ((e.key === 'Enter' || e.key === 'l') && currentIndex >= 0) {
						items[currentIndex].click();
					} else if (e.key === 'Backspace' && currentUtility) {
						goBackToDirectory();
					}
				});

				// Auto-focus terminal input and setup directory items
				terminalInput.focus();
				setupDirectoryItems();
				// make sure prompt displays current directory on load
				updatePrompt();

				// Focus first item by default
				const firstItem = document.querySelector('.directory-item');
				if (firstItem) {
					firstItem.classList.add('selected');
				}

				// Sync hover with selection
				const items = document.querySelectorAll('.directory-item');
				items.forEach(function(item) {
					item.addEventListener('mouseenter', function() {
						items.forEach(function(i) { i.classList.remove('selected'); });
						item.classList.add('selected');
					});
				});
			});

			</script>

			<script set:html={`
			window.utilitiesData = ${serializedUtilitiesData};
			window.fileSystem = ${serializedFileSystem};
			`}></script>
	</body>
</html>
