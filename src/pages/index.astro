---
// Load utilities markdown modules and extract rendered HTML for inline embedding.
const modules = import.meta.glob('../content/utilities/*.md', { eager: true });
const utilitiesData = [];

for (const path in modules) {
	const mod = modules[path];
	const fileName = path.split('/').pop();
	const id = fileName.replace(/\.md$/i, '');
	let content = '';

	if (mod && typeof mod.compiledContent === 'function') {
		try { content = await mod.compiledContent(); } catch (e) { /* ignore */ }
	}
	if (!content && typeof mod.compiled === 'string') {
		content = mod.compiled;
	}
	if (!content && mod && typeof mod.render === 'function') {
		try {
			const r = await mod.render();
			if (r && typeof r.html === 'string') content = r.html;
		} catch (e) { /* ignore */ }
	}

	utilitiesData.push({
		id,
		title: (mod?.frontmatter?.title) || id,
		description: (mod?.frontmatter?.description) || '',
		category: (mod?.frontmatter?.category) || '',
		content
	});
}

// Generate dynamic fileSystem for client-side terminal commands
const fileSystem = {
  'github-projects': {
    'bloccChainz': { type: 'project', url: 'https://github.com/rootHytx/bloccChainz' },
    'github': { type: 'project', url: 'https://github.com/rootHytx' },
    'sistemas-embutidos': { type: 'project', url: 'https://github.com/rootHytx/sistemas-embutidos' },
    'trabalho-redes': { type: 'project', url: 'https://github.com/rootHytx/trabalho-redes' }
  },
  'utilities': Object.fromEntries(
    utilitiesData.map(u => [u.id, { type: 'utility', url: u.id }])
  )
};
const serializedFileSystem = JSON.stringify(fileSystem);
---



<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="rootHytx - Terminal-style cybersecurity portfolio with utilities, projects, and tools." />
		<meta name="author" content="rootHytx" />
		<meta property="og:title" content="root/hytx" />
		<meta property="og:description" content="Terminal-style cybersecurity portfolio with utilities, projects, and tools." />
		<meta property="og:type" content="website" />
		<meta property="og:url" content="https://roothytx.github.io/" />
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:title" content="root/hytx" />
		<meta name="twitter:description" content="Terminal-style cybersecurity portfolio with utilities, projects, and tools." />
		<title>root/hytx</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			.sr-only {
				position: absolute;
				width: 1px;
				height: 1px;
				padding: 0;
				margin: -1px;
				overflow: hidden;
				clip: rect(0, 0, 0, 0);
				white-space: nowrap;
				border: 0;
			}

			@font-face {
				font-family: 'Hack Nerd Font';
				src: url('/fonts/HackNerdFont-Regular.woff2') format('woff2');
				font-weight: 400;
				font-style: normal;
				font-display: swap;
			}
			@font-face {
				font-family: 'Hack Nerd Font';
				src: url('/fonts/HackNerdFont-Bold.woff2') format('woff2');
				font-weight: 700;
				font-style: normal;
				font-display: swap;
			}
			body {
				background-color: #000000;
				color: #e79cfe;
				/* Use Hack Nerd Font as primary, fall back to common monospace fonts */
				font-family: 'Hack Nerd Font', monospace;
				font-size: 16px;
				line-height: 1.4;
				/* overall page uses full viewport height; layout splits into two areas using vh */
				min-height: 100vh;
				margin: 0;
				display: block;
			}

			.content {
				flex: 1;
				display: flex;
				flex-direction: column;
				align-items: center;
				text-align: center;
				max-width: 800px;
				width: 100%;
				margin: 0 auto;
				padding: 2% 0 0 0;
			}

			.content-area {
				width: 100%;
				/* main content takes 70% of the viewport */
				height: 65vh;
				position: relative;
				overflow: auto;
				box-sizing: border-box;
			}

			.header {
				margin-bottom: 30px;
				display: flex;
				align-items: center;
				gap: 8px;
				justify-content: center;
			}

			.username {
				font-size: 26px;
				font-weight: bold;
				color: #e79cfe;
			}

			.cursor {
				display: inline-block;
				width: 8px;
				height: 16px;
				background-color: #e79cfe;
				animation: blink 1s infinite;
				vertical-align: middle;
			}

			@keyframes blink {
				0%, 50% { opacity: 1; }
				51%, 100% { opacity: 0; }
			}


			.utility-content {
				width: 100%;
				text-align: left;
				display: none;
				/* Fill the available area inside the content-area (70%) */
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background-color: #000000;
				z-index: 10;
				overflow-y: auto;
				padding: 20px;
				/* Custom scrollbar */
				scrollbar-width: thin;
				scrollbar-color: #e79cfe #000000;
				box-sizing: border-box;
			}

			.utility-content::-webkit-scrollbar {
				width: 8px;
			}

			.utility-content::-webkit-scrollbar-track {
				background: #000000;
			}

			.utility-content::-webkit-scrollbar-thumb {
				background: #e79cfe;
				border-radius: 4px;
			}

			.utility-content::-webkit-scrollbar-thumb:hover {
				background: #d18bf5;
			}

			.utility-content.active {
				display: block;
			}

			.utility-content-inner {
				/* main content area inner container */
				max-width: 960px;
				margin: 0 auto;
				padding: 20px;
			}

			/* Utility content descendant styles are in <style is:global> below */

			.back-button {
				color: #e79cfe;
				text-decoration: none;
				border-bottom: 1px solid #e79cfe;
				padding-bottom: 2px;
				transition: color 0.2s ease;
				cursor: pointer;
				margin-bottom: 20px;
				display: inline-block;
			}

			.back-button:hover {
				color: #ffffff;
				border-bottom-color: #ffffff;
			}

			.directory-path {
				color: #e79cfe;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 16px;
				margin-bottom: 8px;
				text-align: left;
			}

			.directory-item {
				display: flex;
				align-items: center;
				gap: 4px;
				padding: 4px 16px;
				cursor: pointer;
				transition: color 0.2s ease;
				justify-content: flex-start;
				width: 100%;
			}

			.directory-item:hover,
			.directory-item.selected {
				color: #ffffff;
			}

			.folder-icon {
				color: #e79cfe;
				font-family: monospace;
			}


			.footer {
				color: #666;
				font-size: 14px;
				text-align: center;
			}

			/* Terminal container (fixed to bottom). All terminal-related children (output and the input area)
			   are scoped under this .terminal wrapper so content does not leak into terminal area. */
			.terminal {
				position: fixed;
				left: 0;
				right: 0;
				bottom: 0;
				height: 25%; /* reserved vertical space for the terminal */
				display: flex;
				flex-direction: column;
				justify-content: space-between;
				background-color: #000000;
				z-index: 1000;
				box-sizing: border-box;
			}

			/* Terminal output sits above the input area inside the terminal container and scrolls independently */
			.terminal .terminal-output {
				position: absolute;
				top: 10%;
				left: 1%;
				right: 1%;
				bottom: 0%;
				/* leave room for the input area at the bottom of the terminal */
				max-height: 75%;
				overflow-y: auto;
				background-color: rgba(0, 0, 0, 0.8);
				border: 1px solid #333;
				padding: 10px;
				display: block;
				box-sizing: border-box;
				/* Custom scrollbar to match utilities area */
				scrollbar-width: thin;
				scrollbar-color: #e79cfe #000000;
			}
			.terminal .terminal-output::-webkit-scrollbar {
				width: 8px;
			}
			.terminal .terminal-output::-webkit-scrollbar-track {
				background: #000000;
			}
			.terminal .terminal-output::-webkit-scrollbar-thumb {
				background: #e79cfe;
				border-radius: 4px;
			}
			.terminal .terminal-output::-webkit-scrollbar-thumb:hover {
				background: #d18bf5;
			}

			/* Input area (real-terminal) anchored to the bottom of the .terminal container */
			.terminal .real-terminal {
				position: absolute;
				left: 0;
				right: 0;
				bottom: 0;
				height: 15%; /* fixed input area height within the terminal */
				background-color: #000000;
				border-top: 1px solid #333;
				padding: 12px 20px;
				display: flex;
				align-items: center;
				gap: 8px;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 16px;
				box-sizing: border-box;
			}

			.terminal-prompt {
				color: #e79cfe;
				font-weight: bold;
				white-space: nowrap;
			}

			.terminal-input {
				background: transparent;
				border: none;
				color: #bbb;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 16px;
				outline: none;
				flex: 1;
				caret-color: #e79cfe;
			}

			.terminal-input::placeholder {
				color: #666;
			}

			/* .terminal-output active rule removed — terminal output is visible by default inside .terminal */

			.terminal-line {
				color: #e79cfe;
				line-height: 1.4;
				margin-bottom: 4px;
				white-space: pre-wrap;
			}

			.terminal-command {
				color: #00ff00;
			}

			@media (max-width: 768px) {
				.content {
					max-width: 100%;
					padding: 2% 8px 0 8px;
				}

				.header {
					margin-bottom: 16px;
				}

				.username {
					font-size: 20px;
				}

				.content-area {
					height: 55vh;
				}

				.directory-item {
					padding: 3px 8px;
					font-size: 13px;
				}

				.terminal .real-terminal {
					padding: 8px 12px;
				}

				.terminal-input,
				.terminal-prompt {
					font-size: 14px;
				}

				.footer {
					font-size: 11px;
					padding: 2px 8px;
				}
			}

			@media (max-width: 480px) {
				.username {
					font-size: 16px;
				}

				.content-area {
					height: 50vh;
				}

				.directory-item {
					font-size: 12px;
				}

				.terminal-input,
				.terminal-prompt {
					font-size: 13px;
				}
			}

		</style>
		<style is:global>
			.code-block-wrapper {
				position: relative;
			}

			.code-block-wrapper pre {
				margin: 0;
				padding: 16px 20px !important;
			}

			.copy-btn {
				position: absolute;
				top: 6px;
				right: 6px;
				background: none;
				border: none;
				color: #999;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 16px;
				padding: 2px 4px;
				cursor: pointer;
				opacity: 0.7;
				transition: opacity 0.2s ease, transform 0.15s ease;
				z-index: 5;
				line-height: 1;
			}

			.copy-btn.copied {
				font-size: 11px;
				font-style: italic;
				color: #e79cfe;
				border: 1px solid #e79cfe;
				border-radius: 3px;
				padding: 2px 6px;
			}

			.copy-btn:hover {
				opacity: 1 !important;
				transform: scale(1.15);
			}

			.code-block-wrapper.focused pre {
				outline: 2px solid #e79cfe;
				outline-offset: -2px;
				border-radius: 4px;
			}

			/* Utility content descendant styles (must be global for dynamically injected markdown) */
			.utility-content h1,
			.utility-content h2,
			.utility-content h3 {
				color: #e79cfe;
				margin: 20px 0 10px 0 !important;
				font-family: 'Hack Nerd Font', monospace;
			}

			.utility-content h1 {
				font-size: 24px;
				border-bottom: 1px solid #333;
				padding-bottom: 10px !important;
			}

			.utility-content h2 {
				font-size: 20px;
			}

			.utility-content h3 {
				font-size: 18px;
			}

			.utility-content p {
				color: #e79cfe;
				line-height: 1.6;
				margin: 10px 0 !important;
				font-family: 'Hack Nerd Font', monospace;
			}

			.utility-content .code-block {
				background-color: #1a1a1a;
				border: 1px solid #333;
				padding: 15px !important;
				border-radius: 4px;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 14px;
				line-height: 1.4;
				color: #e79cfe;
				overflow-x: auto;
				margin: 15px 0 !important;
				white-space: pre-wrap;
			}

			.utility-content .section {
				margin: 20px 0 !important;
			}

			.utility-content .back-link {
				color: #e79cfe;
				text-decoration: none;
				border-bottom: 1px solid #e79cfe;
				padding-bottom: 2px !important;
				transition: color 0.2s ease;
				margin-top: auto;
				width: fit-content;
				display: inline-block;
				margin-bottom: 20px !important;
			}

			.utility-content .back-link:hover {
				color: #ffffff;
				border-bottom-color: #ffffff;
			}

			/* Keybind cheat sheet modal */
			.keybind-modal {
				display: none;
				position: fixed;
				inset: 0;
				z-index: 9999;
				background: rgba(0, 0, 0, 0.85);
				align-items: center;
				justify-content: center;
			}

			.keybind-modal.active {
				display: flex;
			}

			.keybind-modal-content {
				background: #111;
				border: 1px solid #e79cfe;
				border-radius: 6px;
				padding: 36px 48px !important;
				max-width: 900px;
				width: 92%;
				max-height: 80vh;
				overflow-y: auto;
				scrollbar-width: thin;
				scrollbar-color: #e79cfe #111;
				font-family: 'Hack Nerd Font', monospace;
				color: #e79cfe;
			}

			.keybind-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				border-bottom: 1px solid #333;
				padding-bottom: 12px !important;
				margin-bottom: 20px !important;
				font-size: 18px;
				font-weight: bold;
			}

			.keybind-close {
				font-size: 12px;
				font-weight: normal;
				color: #666;
			}

			.keybind-columns {
				display: flex;
				flex-wrap: wrap;
				gap: 24px;
			}

			.keybind-section {
				flex: 1 1 280px;
				min-width: 250px;
				margin-bottom: 8px !important;
			}

			.keybind-section-title {
				font-size: 14px;
				font-weight: bold;
				color: #fff;
				margin-bottom: 10px !important;
				border-bottom: 1px solid #333;
				padding-bottom: 6px !important;
			}

			.keybind-row {
				display: flex;
				align-items: center;
				padding: 4px 0 !important;
				font-size: 13px;
			}

			.keybind-row kbd {
				background: #222;
				border: 1px solid #444;
				border-radius: 3px;
				padding: 2px 7px !important;
				margin-right: 4px !important;
				font-family: 'Hack Nerd Font', monospace;
				font-size: 12px;
				color: #e79cfe;
				white-space: nowrap;
			}

			.keybind-row span {
				color: #999;
				margin-left: auto;
				padding-left: 16px !important;
				white-space: nowrap;
			}

			@media (max-width: 768px) {
				.keybind-modal-content {
					padding: 20px 16px !important;
					width: 96% !important;
				}

				.keybind-columns {
					flex-direction: column !important;
				}

				.utility-content h1 {
					font-size: 1.4em !important;
				}

				.utility-content h2 {
					font-size: 1.1em !important;
				}

				.code-block-wrapper pre {
					font-size: 13px !important;
				}
			}
		</style>
	</head>
	<body>

		<div class="content" role="application" aria-label="Terminal portfolio">
			<div class="header" role="banner">
				<span class="username">root/hytx</span>
				<span class="cursor"></span>
			</div>

			<div class="content-area">
				<div id="directory-view" role="navigation" aria-label="Directory listing">
					<div class="directory-path">/root/github-projects</div>
					<div class="directory-listing">
						<div class="directory-item" data-type="project" data-url="https://github.com/rootHytx/sistemas-embutidos" data-content-length="0">
							<span class="folder-icon">└─</span>
							<span class="project-path">/root/github-projects/sistemas-embutidos</span>
						</div>
						<div class="directory-item" data-type="project" data-url="https://github.com/rootHytx/bloccChainz" data-content-length="0">
							<span class="folder-icon">└─</span>
							<span class="project-path">/root/github-projects/bloccChainz</span>
						</div>
						<div class="directory-item" data-type="project" data-url="https://github.com/rootHytx/trabalho-redes" data-content-length="0">
							<span class="folder-icon">└─</span>
							<span class="project-path">/root/github-projects/trabalho-redes</span>
						</div>
						<div class="directory-item" data-type="project" data-url="https://github.com/rootHytx" data-content-length="0">
							<span class="folder-icon">└─</span>
							<span class="project-path">/root/github-projects/github</span>
						</div>
					</div>

					<div class="directory-path" style="margin-top: 30px;">/root/utilities</div>
					{utilitiesData.map((u) => (
						<div class="directory-item" data-type="utility" data-url={u.id.replace(/\.md$/i, '')} data-content-length={u.content ? u.content.length : 0}>
							<span class="folder-icon">└─</span>
							<span class="project-path">{`/root/utilities/${u.id.replace(/\.md$/i, '')}`}</span>
							<!-- Hidden inline copy of the rendered markdown HTML (server-rendered). Inject raw HTML with set:html -->
							<div class="item-content" style="display:none;" set:html={u.content}></div>
						</div>
					))}
				</div>

				<div id="utility-view" class="utility-content" role="article" aria-label="Utility content">
					<div class="utility-content-inner">
						<div class="back-button" id="back-button" role="button" tabindex="0" aria-label="Back to directory listing">← Back to directory</div>
						<div id="utility-content"></div>
					</div>
				</div>
			</div>
		</div>

		<div class="terminal">
			<div class="footer">
				<span>Press ESC to toggle input focus | Press ? for keybinds</span>
			</div>

			<div class="terminal-output" id="terminal-output" role="log" aria-live="polite" aria-label="Terminal output"></div>

			<div class="real-terminal">
				<div class="terminal-prompt">[rootHytx@github.io: <span id="prompt-dir">~</span>]$</div>
				<label for="terminal-input" class="sr-only">Terminal command input</label>
				<input type="text" class="terminal-input" id="terminal-input" placeholder="Type commands here..." aria-label="Terminal command input" autocomplete="off">
			</div>
		</div>

		<div id="keybind-modal" class="keybind-modal" role="dialog" aria-modal="true" aria-labelledby="keybind-modal-title" aria-hidden="true">
			<div class="keybind-modal-content">
				<div class="keybind-header">
					<span id="keybind-modal-title">Keybinds Cheat Sheet</span>
					<span class="keybind-close">Press ? or ESC to close</span>
				</div>
				<div class="keybind-columns">
					<div class="keybind-section">
						<div class="keybind-section-title">Global</div>
						<div class="keybind-row"><kbd>ESC</kbd><span>Toggle terminal input focus</span></div>
						<div class="keybind-row"><kbd>?</kbd><span>Toggle this cheat sheet</span></div>
					</div>
					<div class="keybind-section">
						<div class="keybind-section-title">Directory Navigation</div>
						<div class="keybind-row"><kbd>j</kbd> <kbd>&#x2193;</kbd><span>Move selection down</span></div>
						<div class="keybind-row"><kbd>k</kbd> <kbd>&#x2191;</kbd><span>Move selection up</span></div>
						<div class="keybind-row"><kbd>l</kbd> <kbd>Enter</kbd><span>Open selected item</span></div>
						<div class="keybind-row"><kbd>Backspace</kbd><span>Go back from utility</span></div>
					</div>
					<div class="keybind-section">
						<div class="keybind-section-title">Utility View - Scroll</div>
						<div class="keybind-row"><kbd>j</kbd> <kbd>&#x2193;</kbd><span>Scroll down</span></div>
						<div class="keybind-row"><kbd>k</kbd> <kbd>&#x2191;</kbd><span>Scroll up</span></div>
						<div class="keybind-row"><kbd>Ctrl+d</kbd><span>Half-page down</span></div>
						<div class="keybind-row"><kbd>Ctrl+u</kbd><span>Half-page up</span></div>
						<div class="keybind-row"><kbd>g</kbd> <kbd>Home</kbd><span>Scroll to top</span></div>
						<div class="keybind-row"><kbd>G</kbd> <kbd>End</kbd><span>Scroll to bottom</span></div>
						<div class="keybind-row"><kbd>PgDn</kbd> <kbd>PgUp</kbd><span>Page scroll</span></div>
					</div>
					<div class="keybind-section">
						<div class="keybind-section-title">Utility View - Code Blocks</div>
						<div class="keybind-row"><kbd>h</kbd> <kbd>&#x2190;</kbd><span>Scroll focused block left</span></div>
						<div class="keybind-row"><kbd>l</kbd> <kbd>&#x2192;</kbd><span>Scroll focused block right</span></div>
						<div class="keybind-row"><kbd>y</kbd><span>Yank (copy) focused block</span></div>
					</div>
					<div class="keybind-section">
						<div class="keybind-section-title">Terminal</div>
						<div class="keybind-row"><kbd>Tab</kbd><span>Autocomplete commands/files</span></div>
						<div class="keybind-row"><kbd>Enter</kbd><span>Execute command</span></div>
					</div>
				</div>
			</div>
		</div>

		<script>
			// Simple command system
			document.addEventListener('DOMContentLoaded', function() {
				let isInputFocused = false; // Start with directory navigation focused
				const terminalOutput = document.getElementById('terminal-output') as HTMLElement | null;
				const terminalInput = document.getElementById('terminal-input') as HTMLInputElement | null;
				const directoryListing = document.querySelector('.directory-listing');
				const directoryPath = document.querySelector('.directory-path');
				const footer = document.querySelector('.footer');

				// Directory structure - loaded from server-side generated data
				let fileSystem = window.fileSystem || {
					'github-projects': {
						'bloccChainz': { type: 'project', url: 'https://github.com/rootHytx/bloccChainz' },
						'github': { type: 'project', url: 'https://github.com/rootHytx' },
						'sistemas-embutidos': { type: 'project', url: 'https://github.com/rootHytx/sistemas-embutidos' },
						'trabalho-redes': { type: 'project', url: 'https://github.com/rootHytx/trabalho-redes' }
					},
					'utilities': {}
				};

				// If fileSystem is a string (JSON), parse it
				if (typeof fileSystem === 'string') {
					try {
						fileSystem = JSON.parse(fileSystem);
					} catch (e) {
						console.error('Failed to parse fileSystem:', e);
					}
				}

				let currentUtility = null;

				let currentDirectory = '~';

				// Escape HTML to prevent XSS in terminal output
				function escapeHtml(str) {
					const div = document.createElement('div');
					div.textContent = str;
					return div.innerHTML;
				}

				// Command definitions
				const commands = {
					help: function(): string {
						return `
Available commands:
- help: Show this help message
- ls: List files in current directory
- cd [directory]: Navigate to directory
- cat [file]: Read file contents
- clear: Clear the terminal
- pwd: Show current directory
						`;
					},
					ls: function(): string {
							if (currentDirectory === '~') {
								return Object.keys(fileSystem).map(dir => dir + '/').join('\n');
							} else if (fileSystem[currentDirectory]) {
								return Object.keys(fileSystem[currentDirectory]).join('\n');
							}
							return '';
						},
					cd: function(dir: string): string {
						if (!dir) {
							currentDirectory = '~';
							updatePrompt();
							return '';
						}

						if (dir === '..' || dir === '../') {
							currentDirectory = '~';
							updatePrompt();
							return '';
						}

						// Remove trailing slash if present
						const dirName = dir.replace(/\/$/, '');
						if (fileSystem[dirName]) {
							currentDirectory = dirName;
							updatePrompt();
							return '';
						}

						return 'cd: ' + escapeHtml(dir) + ': No such directory';
					},
					cat: function(file: string): string {
						if (!file) {
							return 'Usage: cat [filename]';
						}

						if (currentDirectory === 'github-projects') {
							const project = fileSystem['github-projects'][file as keyof typeof fileSystem['github-projects']];
							if (project) {
								// Open the project URL
								window.open(project.url, '_blank');
								return `Opening ${file}...`;
							}
						} else if (currentDirectory === 'utilities') {
							const utility = fileSystem['utilities'][file as keyof typeof fileSystem['utilities']];
							if (utility) {
								// Load utility content in-place
								loadUtility(file);
								return `Loading ${file}...`;
							}
						}

						return 'cat: ' + escapeHtml(file) + ': No such file';
					},
					pwd: function(): string {
						return currentDirectory === '~' ? '/root' : `/root/${currentDirectory}`;
					},
					clear: function(): string {
						if (!terminalOutput) return '';
						terminalOutput.innerHTML = '';
						return '';
					}
				};

				// Execute command
				function executeCommand(input: string) {
					if (!terminalOutput) return;

					const parts = input.trim().split(' ');
					const command = parts[0].toLowerCase();
					const args = parts.slice(1);

					if (commands[command as keyof typeof commands]) {
						const result = commands[command as keyof typeof commands](...args);
						if (result) {
							terminalOutput.innerHTML += '<div class="terminal-line">' + result.replace(/\n/g, '<br>') + '</div>';
						}
					} else if (input.trim()) {
						terminalOutput.innerHTML += '<div class="terminal-line">Command not found: ' + escapeHtml(command) + '. Type "help" for available commands.</div>';
					}

					terminalOutput.scrollTop = terminalOutput.scrollHeight;
				}

				// Tab completion handler
				function handleTabCompletion(inputText: string) {
					if (!terminalInput || !terminalOutput) return inputText;

					const parts = inputText.trim().split(/\s+/);
					const cursorPos = terminalInput.selectionStart ?? inputText.length;
					const textBeforeCursor = inputText.substring(0, cursorPos);
					const currentPartIndex = textBeforeCursor.trim().split(/\s+/).length - 1;
					const isCommand = currentPartIndex === 0;

					if (isCommand) {
						// Complete command name
						const partial = parts[0] || '';
						const matches = Object.keys(commands).filter(cmd =>
							cmd.startsWith(partial.toLowerCase())
						);

						if (matches.length === 1) {
							return matches[0] + ' ';
						} else if (matches.length > 1) {
							// Find common prefix
							let commonPrefix = matches[0];
							for (let i = 1; i < matches.length; i++) {
								while (!matches[i].startsWith(commonPrefix)) {
									commonPrefix = commonPrefix.slice(0, -1);
								}
							}
							if (commonPrefix.length > partial.length) {
								return commonPrefix;
							} else {
								// Show available matches
								terminalOutput.innerHTML += '<div class="terminal-line">' + matches.join('  ') + '</div>';
								terminalOutput.scrollTop = terminalOutput.scrollHeight;
								return inputText;
							}
						}
					} else {
						// Complete argument (file/directory)
						const command = parts[0]?.toLowerCase() || '';
						const partial = parts[currentPartIndex] || '';

						let matches: string[] = [];
						if (command === 'cd') {
							// Directory completion
							if (currentDirectory === '~') {
								matches = Object.keys(fileSystem).map(dir => dir + '/').filter(dir =>
									dir.startsWith(partial)
								);
							} else if (fileSystem[currentDirectory]) {
								matches = Object.keys(fileSystem[currentDirectory]).filter(item =>
									item.startsWith(partial)
								);
								// Add ../ for navigation
								if ('../'.startsWith(partial)) {
									matches.push('../');
								}
							}
						} else if (command === 'cat' || command === 'ls') {
							// File completion (same as directory completion for this system)
							if (currentDirectory === '~') {
								matches = Object.keys(fileSystem).map(dir => dir + '/').filter(file =>
									file.startsWith(partial)
								);
							} else if (fileSystem[currentDirectory]) {
								matches = Object.keys(fileSystem[currentDirectory]).filter(file =>
									file.startsWith(partial)
								);
							}
						}

						// Process matches
						if (matches.length === 1) {
							const lastPartialIndex = textBeforeCursor.lastIndexOf(partial);
							const completion = matches[0] + (matches[0].endsWith('/') ? '' : ' ');
							return inputText.substring(0, lastPartialIndex) + completion + inputText.substring(cursorPos);
						} else if (matches.length > 1) {
							// Find common prefix
							let commonPrefix = matches[0];
							for (let i = 1; i < matches.length; i++) {
								while (!matches[i].startsWith(commonPrefix)) {
									commonPrefix = commonPrefix.slice(0, -1);
								}
							}
							if (commonPrefix.length > partial.length) {
								const lastPartialIndex = textBeforeCursor.lastIndexOf(partial);
								return inputText.substring(0, lastPartialIndex) + commonPrefix + inputText.substring(cursorPos);
							} else {
								// Show available matches
								terminalOutput.innerHTML += '<div class="terminal-line">' + matches.join('  ') + '</div>';
								terminalOutput.scrollTop = terminalOutput.scrollHeight;
								return inputText;
							}
						}
					}

					return inputText; // No matches
				}

				// Toggle input focus
				function toggleInputFocus() {
					isInputFocused = !isInputFocused;

					if (isInputFocused) {
						terminalInput!.focus();
						terminalInput!.placeholder = "Type commands here...";
					} else {
						terminalInput!.blur();
						terminalInput!.placeholder = "Press ESC to focus input...";
					}
				}

				// Update the visible prompt directory shown to the user
				function updatePrompt() {
					const promptDirEl = document.getElementById('prompt-dir');
					if (promptDirEl) {
						promptDirEl.textContent = currentDirectory === '~' ? '~' : currentDirectory;
					}
				}

				// Load utility content from inline .item-content elements in the DOM
				function loadUtility(utilityName) {
					const normalizedName = (utilityName || '').toString().replace(/\.md$/i, '');
					currentUtility = normalizedName;

					const directoryView = document.getElementById('directory-view');
					const utilityView = document.getElementById('utility-view');
					const utilityContentDiv = document.getElementById('utility-content');

					directoryView.style.display = 'none';
					utilityView.classList.add('active');

					const directoryItem = document.querySelector('.directory-item[data-url="' + normalizedName + '"]');
					if (directoryItem) {
						const inline = directoryItem.querySelector('.item-content');
						if (inline && inline.innerHTML && inline.innerHTML.trim()) {
							utilityContentDiv.innerHTML = '<div class="utility-content">' + inline.innerHTML + '</div>';
							injectCopyButtons(utilityContentDiv);
							updateFocusedCodeBlock();
							return;
						}
					}
					utilityContentDiv.innerHTML = '<div class="terminal-line">Error: Could not load utility content for ' + escapeHtml(normalizedName) + '</div>';
				}

				// Wrap each <pre> in a div and add a copy button overlay
				function injectCopyButtons(container) {
					if (!container) return;
					const preBlocks = Array.from(container.querySelectorAll('pre'));
					preBlocks.forEach(function(pre) {
						// Skip if already wrapped
						if (pre.parentElement && pre.parentElement.classList.contains('code-block-wrapper')) return;

						const wrapper = document.createElement('div');
						wrapper.className = 'code-block-wrapper';
						pre.parentNode.insertBefore(wrapper, pre);
						wrapper.appendChild(pre);

						const btn = document.createElement('button');
						btn.className = 'copy-btn';
						btn.textContent = '\uF0C5';
						btn.addEventListener('click', function(e) {
							e.stopPropagation();
							const code = pre.querySelector('code');
							const text = code ? code.textContent : pre.textContent;
							navigator.clipboard.writeText(text).then(function() {
								btn.textContent = 'Text Copied';
								btn.classList.add('copied');
								setTimeout(function() {
									btn.textContent = '\uF0C5';
									btn.classList.remove('copied');
								}, 2000);
							});
						});
						wrapper.appendChild(btn);
					});
				}

				// Go back to directory view
				function goBackToDirectory() {
					const directoryView = document.getElementById('directory-view');
					const utilityView = document.getElementById('utility-view');

					directoryView.style.display = 'block';
					utilityView.classList.remove('active');
					currentUtility = null;
				}

				// Command input handler
				terminalInput.addEventListener('keydown', function(e) {
					if (e.key === 'Enter') {
						e.preventDefault(); // Prevent any default behavior
						const command = terminalInput!.value;
						if (command.trim()) {
							// Update prompt with current directory
							const promptDir = currentDirectory === '~' ? '~' : currentDirectory;
							terminalOutput!.innerHTML += '<div class="terminal-line"><span class="terminal-command">[rootHytx@github.io: ' + escapeHtml(promptDir) + ']$ ' + escapeHtml(command) + '</span></div>';
							executeCommand(command);
							terminalInput!.value = '';
						}
					} else if (e.key === 'Tab') {
						e.preventDefault(); // Prevent tab from moving focus
						const newText = handleTabCompletion(terminalInput!.value);
						if (newText !== terminalInput!.value) {
							terminalInput!.value = newText;
							// Place cursor at end of completion
							terminalInput!.selectionStart = terminalInput!.selectionEnd = newText.length;
						}
					}
				});

				// Keybind cheat sheet modal
				const keybindModal = document.getElementById('keybind-modal');

				function toggleKeybindModal() {
					if (!keybindModal) return;
					keybindModal.classList.toggle('active');
					keybindModal.setAttribute('aria-hidden', String(!keybindModal.classList.contains('active')));
				}

				function isKeybindModalOpen() {
					return keybindModal && keybindModal.classList.contains('active');
				}

				// ? key handler — works everywhere except when typing in terminal
				document.addEventListener('keydown', function(e) {
					if (e.key === '?' && !(isInputFocused && document.activeElement === terminalInput)) {
						e.preventDefault();
						toggleKeybindModal();
					}
				});

				// Click outside modal content to close
				if (keybindModal) {
					keybindModal.addEventListener('click', function(e) {
						if (e.target === keybindModal) {
							keybindModal.classList.remove('active');
							keybindModal.setAttribute('aria-hidden', 'true');
						}
					});
				}

				// ESC key handler
				document.addEventListener('keydown', function(e) {
					if (e.key === 'Escape') {
						if (isKeybindModalOpen()) {
							keybindModal.classList.remove('active');
							keybindModal.setAttribute('aria-hidden', 'true');
							return;
						}
						if (currentUtility) {
							goBackToDirectory();
						} else {
							toggleInputFocus();
						}
					}
				});

				// Initialize with directory navigation focused
				terminalInput.blur();
				terminalInput.placeholder = "Press ESC to focus input...";
				terminalOutput.classList.add('active');

				// Show help on first load
				if (terminalOutput.innerHTML === '') {
					terminalOutput.innerHTML = '<div class="terminal-line">' + commands.help().replace(/\n/g, '<br>') + '</div>';
					terminalOutput.scrollTop = terminalOutput.scrollHeight;
				}

				// Directory item click handlers
				function setupDirectoryItems() {
					const items = document.querySelectorAll('.directory-item');
					items.forEach(function(item) {
						item.addEventListener('click', function() {
							const type = this.getAttribute('data-type');
							const url = this.getAttribute('data-url');

							if (type === 'project') {
								window.open(url, '_blank');
								return;
							}

							if (type === 'utility') {
								const inline = this.querySelector('.item-content');
								const directoryView = document.getElementById('directory-view');
								const utilityView = document.getElementById('utility-view');
								const utilityContentDiv = document.getElementById('utility-content');

								if (inline && inline.innerHTML && inline.innerHTML.trim()) {
									directoryView.style.display = 'none';
									utilityView.classList.add('active');
									utilityContentDiv.innerHTML = '<div class="utility-content">' + inline.innerHTML + '</div>';
									injectCopyButtons(utilityContentDiv);
									updateFocusedCodeBlock();
									currentUtility = url;
								} else {
									loadUtility(url);
								}
							}
						});
					});
				}

				// Back button handler
				document.getElementById('back-button').addEventListener('click', goBackToDirectory);

				// Find and highlight the topmost visible code block in the utility view
				function updateFocusedCodeBlock() {
					const utilityView = document.getElementById('utility-view');
					if (!utilityView || !utilityView.classList.contains('active')) return;

					const wrappers = utilityView.querySelectorAll('.code-block-wrapper');
					if (!wrappers.length) return;

					const viewRect = utilityView.getBoundingClientRect();
					// Threshold line at 30% from top — blocks that scroll past this are considered "gone"
					const threshold = viewRect.top + utilityView.clientHeight * 0.3;
					const atBottom = utilityView.scrollTop + utilityView.clientHeight >= utilityView.scrollHeight - 5;

					let found = null;

					if (atBottom) {
						// At bottom: pick the last visible code block
						for (let i = wrappers.length - 1; i >= 0; i--) {
							const rect = wrappers[i].getBoundingClientRect();
							if (rect.bottom > viewRect.top && rect.top < viewRect.bottom) {
								found = wrappers[i];
								break;
							}
						}
					} else {
						// Normal: pick the first block whose bottom is still below the threshold
						for (let i = 0; i < wrappers.length; i++) {
							const rect = wrappers[i].getBoundingClientRect();
							// Block must be at least partially visible
							if (rect.bottom > viewRect.top && rect.top < viewRect.bottom) {
								// Pick this block if its bottom hasn't scrolled past the threshold
								if (rect.bottom > threshold) {
									found = wrappers[i];
									break;
								}
							}
						}
						// Fallback: if all blocks are above threshold, pick the last visible one
						if (!found) {
							for (let i = wrappers.length - 1; i >= 0; i--) {
								const rect = wrappers[i].getBoundingClientRect();
								if (rect.bottom > viewRect.top && rect.top < viewRect.bottom) {
									found = wrappers[i];
									break;
								}
							}
						}
					}

					wrappers.forEach(function(w) { w.classList.remove('focused'); });
					if (found) found.classList.add('focused');
				}

				// Listen for scroll on the utility view to update focused block
				(function() {
					const utilityView = document.getElementById('utility-view');
					if (utilityView) {
						utilityView.addEventListener('scroll', updateFocusedCodeBlock);
					}
				})();

				// Keyboard navigation for directory mode and utility scrolling
				document.addEventListener('keydown', function(e) {
					if (isInputFocused) return;
					if (isKeybindModalOpen()) return;

					// Check if we're viewing a utility content (utility view is active)
					const utilityView = document.getElementById('utility-view');
					if (utilityView && utilityView.classList.contains('active')) {
						const focused = utilityView.querySelector('.code-block-wrapper.focused pre');
						const scrollAmount = 40;

						// Horizontal scroll of focused code block: ArrowLeft/ArrowRight/h/l
						if (focused && (e.key === 'ArrowLeft' || e.key === 'h')) {
							e.preventDefault();
							focused.scrollLeft -= scrollAmount;
							return;
						} else if (focused && (e.key === 'ArrowRight' || e.key === 'l')) {
							e.preventDefault();
							focused.scrollLeft += scrollAmount;
							return;
						}

						// Yank (copy) focused code block: y
						if (focused && e.key === 'y') {
							e.preventDefault();
							const code = focused.querySelector('code');
							const text = code ? code.textContent : focused.textContent;
							const btn = focused.parentElement.querySelector('.copy-btn');
							navigator.clipboard.writeText(text).then(function() {
								if (btn) {
									btn.textContent = 'Text Copied';
									btn.classList.add('copied');
									btn.style.opacity = '1';
									setTimeout(function() {
										btn.textContent = '\uF0C5';
										btn.classList.remove('copied');
										btn.style.opacity = '';
									}, 2000);
								}
							});
							return;
						}

						// Vertical scroll: ArrowDown/j
						if (e.key === 'ArrowDown' || e.key === 'j') {
							e.preventDefault();
							utilityView.scrollTop += scrollAmount;
							updateFocusedCodeBlock();
							return;
						// Vertical scroll: ArrowUp/k
						} else if (e.key === 'ArrowUp' || e.key === 'k') {
							e.preventDefault();
							utilityView.scrollTop -= scrollAmount;
							updateFocusedCodeBlock();
							return;
						// Half-page down: Ctrl+d
						} else if (e.key === 'd' && e.ctrlKey) {
							e.preventDefault();
							utilityView.scrollTop += utilityView.clientHeight * 0.5;
							updateFocusedCodeBlock();
							return;
						// Half-page up: Ctrl+u
						} else if (e.key === 'u' && e.ctrlKey) {
							e.preventDefault();
							utilityView.scrollTop -= utilityView.clientHeight * 0.5;
							updateFocusedCodeBlock();
							return;
						} else if (e.key === 'PageDown') {
							e.preventDefault();
							utilityView.scrollTop += utilityView.clientHeight * 0.9;
							updateFocusedCodeBlock();
							return;
						} else if (e.key === 'PageUp') {
							e.preventDefault();
							utilityView.scrollTop -= utilityView.clientHeight * 0.9;
							updateFocusedCodeBlock();
							return;
						// Top of page: Home/gg (g is handled as single key for simplicity -> Home)
						} else if (e.key === 'Home') {
							e.preventDefault();
							utilityView.scrollTop = 0;
							updateFocusedCodeBlock();
							return;
						// Bottom of page: End/G
						} else if (e.key === 'End' || (e.key === 'G' && !e.ctrlKey)) {
							e.preventDefault();
							utilityView.scrollTop = utilityView.scrollHeight;
							updateFocusedCodeBlock();
							return;
						// Top of page: g (double-tap gg handled simply as single g for usability)
						} else if (e.key === 'g' && !e.ctrlKey) {
							e.preventDefault();
							utilityView.scrollTop = 0;
							updateFocusedCodeBlock();
							return;
						}
					}

					// If not scrolling utility content, handle directory navigation
					const items = document.querySelectorAll('.directory-item');
					let currentIndex = -1;

					// Find current focused item
					items.forEach(function(item, index) {
						if (item.classList.contains('selected')) {
							currentIndex = index;
						}
					});

					if (e.key === 'ArrowDown' || e.key === 'j') {
						e.preventDefault();
						const nextIndex = (currentIndex + 1) % items.length;
						items.forEach(function(item) { item.classList.remove('selected'); });
						items[nextIndex].classList.add('selected');
					} else if (e.key === 'ArrowUp' || e.key === 'k') {
						e.preventDefault();
						const prevIndex = currentIndex <= 0 ? items.length - 1 : currentIndex - 1;
						items.forEach(function(item) { item.classList.remove('selected'); });
						items[prevIndex].classList.add('selected');
					} else if ((e.key === 'Enter' || e.key === 'l') && currentIndex >= 0) {
						items[currentIndex].click();
					} else if (e.key === 'Backspace' && currentUtility) {
						goBackToDirectory();
					}
				});

				// Setup directory items (input stays blurred by default)
				terminalInput.blur();
				setupDirectoryItems();
				// make sure prompt displays current directory on load
				updatePrompt();

				// Focus first item by default
				const firstItem = document.querySelector('.directory-item');
				if (firstItem) {
					firstItem.classList.add('selected');
				}

				// Sync hover with selection
				const items = document.querySelectorAll('.directory-item');
				items.forEach(function(item) {
					item.addEventListener('mouseenter', function() {
						items.forEach(function(i) { i.classList.remove('selected'); });
						item.classList.add('selected');
					});
				});
			});

			</script>

			<script set:html={`
			window.fileSystem = ${serializedFileSystem};
			`}></script>
	</body>
</html>
